import { mysqlTable, serial, text, int, varchar, datetime, foreignKey, boolean, tinyint, mysqlEnum, smallint, mediumint, bigint } from 'drizzle-orm/mysql-core';

export const user = mysqlTable('user', {
	id: varchar('id', { length: 255 }).primaryKey(),
	age: int('age'),
	username: varchar('username', { length: 32 }).notNull().unique(),
	passwordHash: varchar('password_hash', { length: 255 }).notNull(),
	email: varchar('email', {length: 255}).notNull()
});

export const session = mysqlTable('session', {
	id: varchar('id', { length: 255 }).primaryKey(),
	userId: varchar('user_id', { length: 255 })
		.notNull()
		.references(() => user.id),
	expiresAt: datetime('expires_at').notNull()
});

// export const word = mysqlTable('word', {
// 	id: serial('id').primaryKey(),
// 	word: varchar('word', { length: 255 })
// 		.notNull()
// });

// Table for 'part_of_speech'
export const partOfSpeech = mysqlTable('part_of_speech', {
	id: varchar('id', { length: 255 }).primaryKey(),
	name: varchar('name', { length: 255 }).notNull(),
});

// Table for 'dictionary_entry'
export const dictionaryEntry = mysqlTable('dictionary_entry', {
	id: int('id').autoincrement().primaryKey(),
	word: varchar('word', { length: 255 }).notNull(),
	freqIndex: int('freqIndex').notNull(),
});

// Table for 'definition_entry'
export const definitionEntry = mysqlTable('definition_entry', {
	id: int('id').autoincrement().primaryKey(),
	dictionaryEntryId: int('dictionaryEntryId').references(() => dictionaryEntry.id, { onDelete: 'cascade' }).notNull(),
	definition: text('definition').notNull(),
	partOfSpeech: varchar('partOfSpeech', { length: 255 }).references(() => partOfSpeech.id, { onDelete: 'cascade' }),
});

// Table for 'word_group'
export const wordGroup = mysqlTable('word_group', {
	id: int('id').autoincrement().primaryKey(),
	name: varchar('name', { length: 255 }).notNull(),
});

export const verb = mysqlTable('verb', {
	id: int('id').autoincrement().primaryKey(),
	infinitive: varchar('infinitive', { length: 255 }).notNull(),
	gerund: varchar('gerund', { length: 255 }),
	impersonalInfinitive: varchar('impersonalInfinitive', { length: 255 }),

	pastParticiple_ms: varchar('pastParticiple_ms', { length: 255 }),
	pastParticiple_fs: varchar('pastParticiple_fs', { length: 255 }),
	pastParticiple_mp: varchar('pastParticiple_mp', { length: 255 }),
	pastParticiple_fp: varchar('pastParticiple_fp', { length: 255 }),
});

export const personalInfinitiveConjugation = mysqlTable('personal_infinitive_conjugation', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const presentIndicative = mysqlTable('present_indicative', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const imperfectIndicative = mysqlTable('imperfect_indicative', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const futureIndicative = mysqlTable('future_indicative', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const preteriteIndicative = mysqlTable('preterite_indicative', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const pluperfectIndicative = mysqlTable('pluperfect_indicative', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const conditional = mysqlTable('conditional', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const presentSubjunctive = mysqlTable('present_subjunctive', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const imperfectSubjunctive = mysqlTable('imperfect_subjunctive', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const futureSubjunctive = mysqlTable('future_subjunctive', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const imperative = mysqlTable('imperative', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const imperativeNegative = mysqlTable('imperative_negative', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	firstPersonSingular:  varchar('firstPersonSingular', { length: 255 }),
	secondPersonSingular:  varchar('secondPersonSingular', { length: 255 }),
	thirdPersonSingular:  varchar('thirdPersonSingular', { length: 255 }),
	firstPersonPlural:  varchar('firstPersonPlural', { length: 255 }),
	secondPersonPlural:  varchar('secondPersonPlural', { length: 255 }),
	thirdPersonPlural:  varchar('thirdPersonPlural', { length: 255 }),
});

export const verbDefinition = mysqlTable('verb_definition', {
	id: int('id').autoincrement().primaryKey(),
	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).notNull(),
	definition: text('definition'),
});

// // Table for 'word_group_entry'
// export const wordGroupEntry = mysqlTable('word_group_entry', {
// 	wordGroupId: int('wordGroupId').notNull(),
// 	dictionaryEntryId: int('dictionaryEntryId').notNull(),

// 	// Primary Key
// 	primaryKey: serial('primaryKey').primaryKey(),

// 	// Foreign Key Relations
// 	foreignKeyWordGroup: foreignKey('wordGroupId').references(wordGroup.id).onDelete('cascade'),
// 	foreignKeyDictionaryEntry: foreignKey('dictionaryEntryId').references(dictionaryEntry.id).onDelete('cascade'),
// });


// User settings:
//     userId: int //pk
//     country
//     saved crossword
//     saved wordsearch
//     last-used grid size ?
//     last-used wordsearch difficulty setting ?
//     last-used preset-ID ?
// savedCrossword: int('savedCrossword').references(() => savedCrossword.id),
// savedWordSearch: int('savedWordsearch').references(() => savedWordsearch.id),
// gridSize: tinyint('gridSize'), // this should really be from the default preset, along with ws difficulty
// wordsearchDifficulty: mysqlEnum('wordsearchDifficulty', ['easy', 'medium', 'difficult']), 
export const userSettings = mysqlTable('user_settings', {
	id: varchar('id', { length: 255 }).references(() => user.id, { onDelete: 'cascade' }).primaryKey(),
	isBrazil: boolean('isBrazil'),
	defaultPreset: int('defaultPreset').references(() => gamePreset.id)
});


// Game presets:
//     id: int
//     verbs_enabled: boolean
//     grid_size: int
//     ws_difficulty: int? enum?
//     cw_include_spaces: boolean
//     cw_include_accents: boolean
//     verb_preset_id: int
//     userId: int
// gameMode: mysqlEnum('gameMode', [
// 	'crossword', 'crossword-spaces',
// 	'wordsearch-easy', 'wordsearch-medium', 'wordsearch-hard'
// ]),

export const gamePreset = mysqlTable('game_preset', {
	id: int('id').autoincrement().primaryKey(),
	enabledPartsOfSpeech: smallint('enabledPartsOfSpeech'), //essentially 16 booleans, one for each Part of speech
	gridSize: tinyint('gridSize'),
	gameMode: tinyint('gameMode'), //enum, but 4 times smaller
	verbPresetId: int('verbPresetId').references(() => verbPreset.id, { onDelete: 'cascade' }),
	creatorId: varchar('creatorId', { length: 255 }).references(() => user.id, { onDelete: 'cascade' }),
});



// Verb presets:
//     verbPresetId: int
//     userId: int
//     verbsManuallyEntered: text  //better than separate table for each verb, because that'd be 255 characters per verb
//     // verb selection can be found through Verb Preset Verb Selction
//     // tenses selection can be calculated
//     auxiliaryVerbCombo: mediumint (there's 24 possibilities)
//     includeGerund: boolean
//     includePastParticiple: boolean
//     includeInfinitive: boolean
//     pronounCombo: smallint (if using 16 or fewer possible pronouns)

export const verbPreset = mysqlTable('verb_preset', {
	id: int('id').autoincrement().primaryKey(),
	creatorId: varchar('creatorId', { length: 255 }).references(() => user.id, { onDelete: 'cascade' }),
	specificVerbs: text('specificVerbs'),
	auxiliaryVerbCombo: mediumint('auxiliaryVerbCombo', {unsigned: true}),
	additionalSettings: boolean('additionalSettings'), //gerund, participles, infinitive
	pronounCombo: smallint('pronounCombo', {unsigned: true})
});

// Verb Selection
//     verbSelectionId: int
//     conjugation_family: enum ()
//     regular: boolean
//     verbClass: enum //transitive, impersonal, etc.
//     inflection_type: enum
//     frequencyFilter: enum //enum to allow space saving

export const verbSelection = mysqlTable('verb_selection', {
	id: int('id').autoincrement().primaryKey(),
	creatorId: varchar('creatorId', { length: 255 }).references(() => user.id, { onDelete: 'cascade' }),
	conjugationFamily: tinyint('conjugationFamily', {unsigned: true}),
	regularity: tinyint('regularity', {unsigned: true}),
	irregularFamiliesA: int('irregularFamiliesA', {unsigned: true}),
	irregularFamiliesB: int('irregularFamiliesB', {unsigned: true}),
	verbClass: tinyint('verbClass', {unsigned: true}),
	inflectionType: smallint('inflectionType', {unsigned: true}),
	frequencyFilter: tinyint('frequencyFilter', {unsigned: true})
});
    
// Verb Preset Verb Selection //many to many relationship
//     verbPresetId: int
//     verbSelectionId: int

export const verbPresetSelection = mysqlTable('verb_preset_selection', {
	id: int('id').autoincrement().primaryKey(),
	verbPreset: int('verbPreset').references(() => verbPreset.id, { onDelete: 'cascade' }),
	verbSelection: int('verbSelection').references(() => verbSelection.id, { onDelete: 'cascade' }),
});


// Tense Selection
//     tenseSelectionId: int
//     mood: enum
//     structure: enum (simple/compound)
//     tense: enum (present/preterite/etc)
//     pt_common_factor: int //how common the tense is in portugal
//     br_common_factor: int //how common the tense is in brazil

const tenseSelection = mysqlTable('tense_selection', {
	id: int('id').autoincrement().primaryKey(),
	mood: tinyint('mood', {unsigned: true}), //indicative, subjunctive, progressive, imperative
	structure: tinyint('structure', {unsigned: true}), // simple or compound
	tense: tinyint('tense', {unsigned: true}), // present, preterite, imperfect, pluperfect, future, conditional
});
    
// Verb Preset Tense Selection //many to many relationship
//     verbPresetId: int
//     tenseSelectionId: int

const verbPresetTense = mysqlTable('verb_preset_tense', {
	id: int('id').autoincrement().primaryKey(),
	verbPreset: int('verbPreset').references(() => verbPreset.id, { onDelete: 'cascade' }),
	tenseSelection: int('tenseSelection').references(() => tenseSelection.id, { onDelete: 'cascade' }),
});

// Auxiliary Verb Selection //only necessary if otherAuxiliaryVerbData is necessary - I think it will be
//     auxiliaryVerbId: int
//     verbId: int
//     otherAuxiliaryVerbData: ?

//AUXILIARY SELECTION CAN BE ADDED LATER:

// const auxiliarySelection = mysqlTable('auxiliary_selection', {
// 	verbId: int('verbId').references(() => verb.id, { onDelete: 'cascade' }).primaryKey(),
// 	other data? required form for example? gerund/participle/infinitive
// });

// export type word = typeof word.$inferSelect;
export type Session = typeof session.$inferSelect;
export type User = typeof user.$inferSelect;
export type PartOfSpeech = typeof partOfSpeech.$inferSelect;
export type DictionaryEntry = typeof dictionaryEntry.$inferSelect;
export type DefinitionEntry = typeof definitionEntry.$inferSelect;
export type WordGroup = typeof wordGroup.$inferSelect;
export type Verb = typeof verb.$inferSelect;
export type PersonalInfinitiveConjugation = typeof personalInfinitiveConjugation.$inferSelect;
export type PresentIndicative = typeof presentIndicative.$inferSelect;
export type ImperfectIndicative = typeof imperfectIndicative.$inferSelect;
export type FutureIndicative = typeof futureIndicative.$inferSelect;
export type PreteriteIndicative = typeof preteriteIndicative.$inferSelect;
export type PluperfectIndicative = typeof pluperfectIndicative.$inferSelect;
export type Conditional = typeof conditional.$inferSelect;
export type PresentSubjunctive = typeof presentSubjunctive.$inferSelect;
export type ImperfectSubjunctive = typeof imperfectSubjunctive.$inferSelect;
export type FutureSubjunctive = typeof futureSubjunctive.$inferSelect;
export type Imperative = typeof imperative.$inferSelect;
export type ImperativeNegative = typeof imperativeNegative.$inferSelect;
export type VerbDefinition = typeof verbDefinition.$inferSelect;
// export type WordGroupEntry = typeof wordGroupEntry.$inferSelect;
export type UserSettings = typeof userSettings.$inferSelect;
export type GamePreset = typeof gamePreset.$inferSelect;
export type VerbPreset = typeof verbPreset.$inferSelect;
export type VerbSelection = typeof verbSelection.$inferSelect;
export type VerbPresetSelection = typeof verbPresetSelection.$inferSelect;
export type TenseSelection = typeof tenseSelection.$inferSelect;
export type VerbPresetTense = typeof verbPresetTense.$inferSelect;
// export type Word = typeof word.$inferSelect;
